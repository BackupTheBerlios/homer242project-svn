3.adbapi
Le but de cette application est de fournir une interface simple et homogène pour travailler avec différentes base de donnée tout en évitant de taper du SQL. Pour ce genre d'application, on parle d'API (il ne fournit pas un programme pour les utilisateurs finaux mais pour d'autres développeurs). \\
adbapi favorise la clarté des applications écrites et offre à ses utilisateurs un einterface composée des méthodes SQL suivantes : INSERT(), SELECT(), UPDATE() et DELETE() ainsi que d'autres fonctionnalités détaillés plus bas.

Un 1er prototype a été écrit par M.~Joël Maïzi. Ca été notre point de départ. Nous l'avons étudier puis améliorer en intégrant le concept de programmation objet.

3.1 L'arbre de représentation

L'intéraction avec la base de donnée se fait via un arbre.

<<Schéma adbapi_tree.png>>

A la racine, nous trouvons l'objet représentant la base de donnée.
Sur cet objet, nous pouvons exécuter des commit (une méthode qui enregistre les modifications dans la base de donnée).

Au second niveau, nous y trouvons tous les schémas de la base de donnée.

Au troisième niveau, Les tables qui se trouvent dans ces schémas.
    Sur ces tables, nous pouvons faire des SELECT, INSERT, DELETE, UPDATE
    
Au feuille, les champs contenus dans les tables.

    Nous pouvons affecter des valeurs aux champs.

On accéde au élement en parcourant cet arbre. 


    adbapi v0.1
comme toute première version, adbapi décelait quelques inconvénients (et non pas des bugs) :
    - le non respect de certains principes de la programmation orienté objet~: utilisation de variable globale, décapsulation des attributs des classe~etc.
    - la méthode adbapiTable.DELETE permettait de supprimer tous les tuples d'une table ce qui la rend dangereuse.
    - lors d'un commit, le développeur été incapable de savoir si une transaction s'est bien déroulées ou non.
    - la structure de l'application ne permettait pas l'utilisation de différents modules pour communiquer avec les différents SGBDR
        
    adbapi v0.2
elle essaye de résoudre les différents problèmes de la précédente version. Le plus important changement concerne la structure de l'application. la figure suivante schématise la nouvelle structure : 

************* ICI METTRE L'UML ************************ avec des notes explicatives ***************

 Les modules)

Adbapi a été programmé de façon modulaire. Il est possible de lui ajouter des modules pour gerer d'autres bases de donnée.
Nous avons développé 2 modules (Oracle et postgres).

L'ajout d'un module :

- Il faut hériter de la classe AdbapiDB puis surcharger les méthodes suivantes :

    - connectDb()
    
        C'est la méthode qui instancie la connexion avec la base de donnée.
        
    - buildTreeDb()
    
        C'est la méthode qui crée l'arbre représentant la base de donnée.
    
Ces modules spécifiques à adbapi utilisent d'autres modules de base de donnée de plus bas niveau (interaction en SQL).

Les modules de base de donnée de plus bas niveau doivent être compatible db api2.0 pour fonctionner avec adbapi. C'est à dire :

- Fournir un "cursor". C'est un objet qui permet d'executer des requetes et de retourner les resultats.
- Fournir la méthode fetchall() (dans l'objet cursor) qui retourne sous forme d'un table de tuple le resultat d'une requete SELECT
- Fournir la méthode commit() qui sauvegarde les modifications dans la base de donnée (les requetes INSERT, UPDATE, DELETE n'interagisse 
uniquement avec une représentation de la base de donnée situé dans la mémoire physique (RAM))

    adbapi v0.3
le besoin de s'éloigner le plus possible du langage SQL tout en écrivant des requêtes correctes n'a pas été tout à fait atteint. 
En effet, prenant l'exemple de cette requête : [afficher le nom des personnes ayant plus de 15 ans et moins de 36 ans]; Le programmeur est incapable d'exécuter celle-ci puisque adbapi n'offre pas le moyen d'exprimer des inégalités entre les valeurs.
Pour combler ce vide, M. Maïzi a réécrit la classe adbapiField en lui ajoutant les fonctionnalités souhaitée.
Le principe est d'utiliser une algèbre qui permet de spécifier les contraintes sur les attributs. exemple :



adbapi le retour :
    une fois la première proposition des roles mise en place, nous avons continuer le développement 
d'adbapi :
    * implémentation de l'algébre :

Il nous fallait un système assez complet pour filtrer les résultats d'une requete (par exemple, récupèrer un seul tuple de la table étudiant).

    SELECT * FROM table WHERE (a!=0 AND b='une requete') OR NOT c>4;
    
Quand nous examinons une requete 'simple' en SQL (en particulier la partie après le WHERE), nous voyons :

<<SCHEMA analyse-requete.png>>

- Des éléments (a=0, b='une requete', c>4) où l'on compare la valeur d'un champ à une valeur "statique" (écrite dans la requête) ou celle d'un autre champ.
  Les opérateurs les plus utilisés sont : '=', '<', '>', '!='
- Des opérateurs AND, OR, NOT qui fournit des conditions supplémentaires sur le ou les tuples à selectionner.
  Il y a aussi des parenthèses pour définir la priorité des opérations. On y voit une analogie avec l'algèbre de Boole.

Pour résoudre notre problème, le moyen le plus simple est de créer une algèbre en surchargeant les opérateurs dans python 
et d'ajouter des méthodes à nos adbapiField pour construire les éléments de notre filtre. La mise en place d'une 
algèbre permettra de construire aisement des requètes complexes.


On a donc :

- Rajouter 2 variables permettant de stocker les filtres SQL générés :
    - Une variable qui contient le filtre de l'adbapiField construit grace aux méthodes setOp() et set().
    - et un autre variable qui contient le filtre généré par l'algèbre.
- Surcharger les opérateurs +, - (unaire), et *

Voiçi les règles de cette algèbre (a et b étant des adbapiField) :

    Algèbre Adbapi      SQL
    
        a*b             a AND b
        a+b             a OR b
        a+(-b)          a OR NOT b

L'avantage de cette algèbre est qu'on peut utiliser les priorités des parenthèses pour construire un filtre 
assez complexe tout comme dans une requete SQL :

        a+((-b)*c)      a OR (NOT b AND c)
    
    * implémentation des schémas :
    les schémas dans une base de données forment un moyen d'encapsulation de plusieurs tables dans une même entité logique. Face a une prochaine intégration des schémas dans la construction des futurs bases de données, nous sommes contraint de faire en sorte q'adbapi pressne en charge ces schémas.

    On considère les schémas comme étant des objets qui font partie d'une base de données. chaque schémas contient des tables.
*********************** ICI METRE LE DIAGRAMME UML AVEC LES SCHEMAS **************************************

    * implémentation du mécanisme de jointure :
    adbapi ne permettait pas de faire une séléction impliquant plusieurs tables. ce problème oblige à créer une vue au niveau de la base de données. Cette vue sert à mettre en relation les tables souhaitées. Après, et seulement après cette manoeuvre, qu'on peut récupérer le résultat voulu en effectuant la séléction sur la vue générée.

<<SCHEMAS getrel_schema1.png>>


Solution choisie : 
toute solution devait se baser sur les clés étrangères déjà implémentées dans les SGBDR. en effet les 
clés étrangères est le mécanisme qui permet de lier les tables entres elles. 
Donc la première étape été d'identifier les attributs des tables constituant des clés étrangères puis de stocker dans chacun de ces attributs le nom de la table et de l'attribut pointé. 
La deuxième étape consiste à stocker dans chaque objet adbapiTable le nom des différentes tables pointées ainsi 
que les noms des attributs constituants la clé étrangère. Cette étape est optionnelle mais son résultat permet de 
faciliter certains traitements ultérieurs. 
Puisque chaque clé étrangère correspond à une clé primaire dans une autre relation, la troisième étape consiste à stocker le noms des champs de la clé primaire dans chaque objet adbapiTable.

Nous avons alors ajouter une méthode dans notre classe AdbapiTable appellé 'getRel()' qui répond à utilise les points cités ci-dessus.
Ce qui donne ceçi dans un programme qui utilise cette méthode :
<code>
table_relation = adbapi.public.r_etudiant_module()

# on selectionne un tuple dans la table
table_relation.id_etudiant.setVal(1)
table_relation.id_mention.setVal(356)
table_relation.annee.setVal(2005)
table_relation.semestre.setVal(1)

# on récupére une liste des tables en relation
res = table_relation.getRel()
print res.etudiant.nom.getVal() # affiche 'Klurch'
</code>


    * le type de données manipulées
Pour rappel, un des principaux buts pour lesquels adbapi a été réalisée, est de permettre au programmeur une 
manipulation aisées des différentes informations extraites d'une base de données. Cette manipulation se matérialise pas l'utilisation des types python de base. 
De plus, le programmeur n'a pas besoin de savoir le type de données dans une base de données, car ce dernier peut avoir 
différents type selon le SGBDR utilisé.
Afin d'arriver à cette finalité, l'api doit vérifier que le type des paramétres fournis par le programmeur est bien 
cohérent avec le vrai type de l'objet manipulé.

On intérrogeant les métas données du SGBDR utilisé, on peut savoir le type correspondant à un champ 
d'une table. En stockant cette information, nous sommes capables de controler et de convertir si nécessaire les données 
circulant dans les deux sens suivants : adbapi <--> programmeur.
Le hic est : d'une part chaque SGBDR a ses propres types et d'autre part chaque driver utilisé pour assurer la 
communication avec le SGBDR effectue une convertion vers un type python. Par conséquent on a besoin d'un outil de 
qui vérifie les deux points suivant :
	- lors d'un monChamp.setVAl( valeur ) nous devons vérifier que le type de «valeur» correspond au type du champ 	
«monChamp»
	- lors d'un getVal() nous devons garantir que la valeur retournée est bien de type python est qu'elle est 
cohérente.
Deux solution s'imposent :
	- définir une classe correspondant à chaque type connu pour chaque SGBDR puis dans la classe AdbapiField 
ajouter un attribut qui est une instance de la classe correspondant au type du champ. cette solution présente un 
inconvéniant majeur qui est la multitude d'objet en mémoire
	- la deuxième solution qui est plus raisonnable consiste à créer une classe AdbapiTypes qui sera associée au 
SGBDR utilisé et qui contiendra les méthodes nécessaire pour la conversion dans le sens voulu. C'est cette solution qui 
a été retenue vu la différence du nombre d'objets crées et le coût que ça engendrerait.
<<schema UML>>
Pour chaque module adbapi pour une base de donnée, nous définissons en plus une classe dérivant d'adbapiType se chargeant de la conversion des types. Cette classe contient des méthodes pour convertir dans les 2 sens. Elle s'occupe donc de convertir les données renvoyées par le module de base de donnée bas niveau et les données envoyés par l'utilisateur.

AdbapiOracle :
	Le service informatique utilise aussi un SGBDR de type Oracle. Cette utilisation et le besoin urgent de pouvoir 
développer des applications utilisants des informations stockées dans ce type d'SGBDR nous à inciter à mettre en place 
un module AdbapiOracle qui au même titre que AdbapiPg va se charger de construire l'arbre d'objet adbapi.
	L'organisation d'une base de données Oracle est différente de celle de PostgreSQL. On retrouve les schémas 
"TABLESPACES" comme étant des entités physiques et non logique de stockage, les éspaces de nommage sont le nom du 
propriétaire "OWNER" ou l'identifiant de l'utilisateur qui se connecte "USER". les vues quant à elles forment des 
objets à part entière car elles ne sont attachées à aucun "TABLESPACE" mais plutôt au propriétaire "OWNER".


3.6 Utilisation
Voiçi les étapes communes à toutes applications utilisant adbapi :

1) Etablir une connexion avec la base de donnée en instanciant le bon module (voir le chapitre suivant).
2) Obtenir une copie d'une table
    
    pour eviter de travailler directement avec les tables de l'arbre de représentation de la base de donnée, il faut 
    instancier un nouvel adbapiTable (qui est une copie d'un adbapiTable de l'arbre).
