3.adbapi
adbapi est une application écrite en Python et offre une interface permettant d'exécuter des requêtes SQL simples. 
Elle essaye de simplifier la tache des programmeurs en leur évitant l'écriture de code SQL tout en favorisant la clarté des applications écrites.
aDBapi offre à ses utilisateurs les méthodes SQL suivantes : INSERT, SELECT, UPDATE et DELETE ainsi que d'autres fonctionnalités détaillés plus bas.

    adbapi v0.1
comme toute première version, aDBapi décelait quelques inconvénients (et non pas des bugs) :
    - le non respect de certains principes de la programmation orienté objet (utilisation de variable globale, décapsulation des attributs des classe ....etc)
    - la méthode aDBapiTable.DELETE permettait de supprimer tous les tuples d'une table ce qui la rend dangereuse.
    - lors d'un commit, le développeur été incapable de savoir si une transaction s'est bien déroulées ou non.
    - la structure de l'application ne permettait pas l'utilisation de différents modules pour communiquer avec les différents SGBDR
        
    adbapi v0.2
elle essaye de résoudre les différents problèmes de la précédente version. Le plus important changement concerne la structure de l'application. la figure suivante schématise la nouvelle structure : 

************* ICI METTRE L'UML ******************************** avec des notes explicatives *****************************

    
    adbapi v0.3
le besoin de s'éloigner le plus possible du langage SQL tout en écrivant des requêtes correctes n'a pas été tout à fait atteint. 
En effet, prenant l'exemple de cette requête : [afficher le nom des personnes ayant plus de 15 ans et moins de 36 ans]; Le programmeur est incapable d'exécuter celle-ci puisque adbapi n'offre pas le moyen d'exprimer des inégalités entre les valeurs.
Pour combler ce vide, M. Maïzi a réécrit la classe adbapiField en lui ajoutant les fonctionnalités souhaitée.
Le principe est d'utiliser une algèbre qui permet de spécifier les contraintes sur les attributs. exemple :


5. adbapi le retour :
    une fois la première proposition des roles mise en place, nous avons continuer le développement 
d'adbapi :
    * implémentation de l'algébre :
    
    * implémentation des schémas :
    les schémas dans une base de données forment un moyen d'encapsulation de plusieurs tables dans une même entité logique. Face a une prochaine intégration des schémas dans la construction des futurs bases de données, nous sommes contraint de faire en sorte q'adbapi pressne en charge ces schémas.

    On considère les schémas comme étant des objets qui font partie d'une base de données. chaque schémas contient des tables.
*********************** ICI METRE LE DIAGRAMME UML AVEC LES SCHEMAS **************************************

    * implémentation du mécanisme de jointure :
    adbapi ne permettait pas de faire une séléction impliquant plusieurs tables. ce problème oblige à créer une vue au niveau de la base de données. Cette vue sert à mettre en relation les tables souhaitées. Après, et seulement après cette manoeuvre, qu'on peut récupérer le résultat voulu en effectuant la séléction sur la vue générée.
Le but fixé été de pouvoir éxécuter des instructions de ce type :
<code>
    acteur.id.setVal( 2 )
    resultat = acces_voiture.getRel( acteur )
</code>
en ayant ce diagramme UML :

****************************************** ICI UML ***************************************************

explication : 
acteur.id.setVal( 2 ) : initialisation de l'identifiant d'un acteur à 2
resultat = acces_voiture.getRel( acteur ) : en passant l'objet acteur à la méthode getRel() on veut récupérer la liste des roles ainsi que des voitures qui entrent en relation avec l'acteur dont l'identifiant est 2.
voici un schéma illustrant la situation précédente :

****************************************  ICI METTRE lE SCHEMA ILLUSTRANT ***************************************

Solution choisie : 
toute solution devait se baser sur les clés étrangères déjà implémentées dans les SGBDR. en effet les 
clés étrangères est le mécanisme qui permet de lier les tables entres elles. 
Donc la première étape été d'identifier les attributs des tables constituant des clés étrangères puis de stocker dans chacun de ces attributs le nom de la table et 
de l'attribut pointé. 
La deuxième étape consiste à stocker chaque objet adbapiTable le nom des différentes tables pointées ainsi 
que les noms des attributs constituants la clé étrangère. Cette étape est optionnelle mais son résultat permet de 
faciliter certains traitements ultérieurs. 
Puisque chaque clé étrangère correspond à une clé primaire dans une autre relation, la troisième étape consiste à stocker le noms des champs de la clé primaire dans chaque objet adbapiTable.
On peut voir le résultat à cette page #page

    * Problème : le type de données manipulées
Pour rappel, un des principaux buts pour lesquels adbapi a été réalisée, est de permettre au programmeur une 
manipulation aisées des différentes informations extraites d'une base de données. Cette manipulation se matérialise pas l'utilisation des types python de base. 
De plus, le programmeur n'a pas besoin de savoir le type de données dans une base de données, car ce dernier peut avoir 
différents type selon le SGBDR utilisé.
Afin d'arriver à cette finalité, l'api doit vérifier que le type des paramétres fournis par le programmeur est bien 
cohérent avec le vrai type de l'objet manipulé.

On intérrogeant les métas données du SGBDR utilisé, on peut savoir le type correspondant à un champ 
d'une table. En stockant cette information, nous sommes capables de controler et de convertir si nécessaire les données 
circulant dans les deux sens suivants : adbapi <--> programmeur.
Le hic est : d'une part chaque SGBDR a ses propres types et d'autre part chaque driver utilisé pour assurer la 
communication avec le SGBDR effectue une convertion vers un type python. Par conséquent on a besoin d'un outil de 
qui vérifie les deux points suivant :
	- lors d'un monChamp.setVAl( valeur ) nous devons vérifier que le type de «valeur» correspond au type du champ 	
«monChamp»
	- lors d'un getVal() nous devons garantir que la valeur retournée est bien de type python est qu'elle est 
cohérente.
Deux solution s'imposent :
	- définir une classe correspondant à chaque type connu pour chaque SGBDR puis dans la classe AdbapiField 
ajouter un attribut qui est une instance de la classe correspondant au type du champ. cette solution présente un 
inconvéniant majeur qui est la multitude d'objet en mémoire
	- la deuxième solution qui est plus raisonnable consiste à créer une classe AdbapiTypes qui sera associée au 
SGBDR utilisé et qui contiendra les méthodes nécessaire pour la conversion dans le sens voulu. C'est cette solution qui 
a été retenue vu la différence du nombre d'objets crées et le coût que ça engendrerait.

AdbapiOracle :
	Le service informatique utilise aussi un SGBDR de type Oracle. Cette utilisation et le besoin urgent de pouvoir 
développer des applications utilisants des informations stockées dans ce type d'SGBDR nous à inciter à mettre en place 
un module AdbapiOracle qui au même titre que AdbapiPg va se charger de construire l'arbre d'objet adbapi.
	L'organisation d'une base de données Oracle est différente de celle de PostgreSQL. On retrouve les schémas 
"TABLESPACES" comme étant des entités physiques et non logique de stockage, les éspaces de nommage sont le nom du 
propriétaire "OWNER" ou l'identifiant de l'utilisateur qui se connecte "USER". les vues quant à elles forment des 
objets à part entière car elles ne sont attachées à aucun "TABLESPACE" mais plutôt au propriétaire "OWNER".

6. Les Droits :
les droits qu'un acteur a sur une donnée sont stockées aux niveau de la base de donnée. Certes c'est une solution mais 
elle montre des défauts :
    * on ne peut pas donner des droits sur un ensemble d'attributs mais plutôt sur tout les attributs d'une donnée 
(tuple) .
    * de plus il est difficile de mettre en place un systeme qui permet de définir en cascade les droits sur plusieurs 
données, ex. : un résponsable de spécialité doit avoir le droit d'effectuer certaines opérations sur sa spécialité et 
de consulter les candidatures pour les approuver; Donc changer l'état d'une candidaure donc éditer une candidature.
Tous ceci parsequ'il a le rôle de résponsable de spécialité.
Le modèle actuel ne permet pas de répondre à ces problèmes ce qui nous obligent à jeter tous ce que nous avons fait 
jusqu'à présent (principe de l'eXtrem Programming oblige) et de faire une autre proposition.

6.1. Les patrons s'en chargent !
L'idée est la suivante : lors de la présentation d'une donnée à un acteur du système d'information, on utilisera un patron qui n'affiche que les champs 
susceptibles d'être consulter ou modifier et ceci selon les droits que l'acteur a par rapport à la donnée.

6.2. Rôles en cascade
Le but est d'associer à un rôles principale un ou plusieurs autres rôles dis annexes. Par conséquent un acteur 
ayant un rôle principale sur une donnée se voit attribuer des rôles annexes. Mais il ne faut pas oublier de spécifier 
que le rôle annexe (dans notre cas : le résponsable de condidatures) est posé sur tous les tuples d'une même 
table (la table contenant les candidatures à la spécialité). Donc un role annexe doit avoir un attribut qui spécifie 
la table sur laquelle s'applique ce role.

**********METTRE ICI LE SCHEMA UML**************

6.3 
