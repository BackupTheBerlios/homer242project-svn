3.adbapi
adbapi est une application écrite en Python et offre une interface permettant d'exécuter des requêtes SQL simples. 
Elle essaye de simplifier la tache des programmeurs en leur évitant l'écriture de code SQL tout en favorisant la clarté des applications écrites.
aDBapi offre à ses utilisateurs les méthodes SQL suivantes : INSERT, SELECT, UPDATE et DELETE ainsi que d'autres fonctionnalités détaillés plus bas.

    adbapi v0.1
comme toute première version, aDBapi décelait quelques inconvénients (et non pas des bugs) :
    - le non respect de certains principes de la programmation orienté objet (utilisation de variable globale, décapsulation des attributs des classe ....etc)
    - la méthode aDBapiTable.DELETE permettait de supprimer tous les tuples d'une table ce qui la rend dangereuse.
    - lors d'un commit, le développeur été incapable de savoir si une transaction s'est bien déroulées ou non.
    - la structure de l'application ne permettait pas l'utilisation de différents modules pour communiquer avec les différents SGBDR
        
    adbapi v0.2
elle essaye de résoudre les différents problèmes de la précédente version. Le plus important changement concerne la structure de l'application. la figure suivante schématise la nouvelle structure : 

************* ICI METTRE L'UML ******************************** avec des notes explicatives *****************************

    
    adbapi v0.3
le besoin de s'éloigner le plus possible du langage SQL tout en écrivant des requêtes correctes n'a pas été tout à fait atteint. 
En effet, prenant l'exemple de cette requête : [afficher le nom des personnes ayant plus de 15 ans et moins de 36 ans]; Le programmeur est incapable d'exécuter celle-ci puisque adbapi n'offre pas le moyen d'exprimer des inégalités entre les valeurs.
Pour combler ce vide, M. Maïzi a réécrit la classe adbapiField en lui ajoutant les fonctionnalités souhaitée.
Le principe est d'utiliser une algèbre qui permet de spécifier les contraintes sur les attributs. exemple :


4. Systeme d'information
le service informatique de l'UFR propose souvent de nouveaux services au core enseignant ainsi qu'aux étudiants; 
Ceci implique la création de nouvelles applications (Web entre autre). Une application Web est couplée, dans la plupart du temps, à une base de données. 
Afin de donner plus de liberté aux enseignants dans la manipulation des données qui les intéressent, Une approche a vu le jour : on peut considérer un system d'information comme étant un ensemble de donnée sur lesquelles des acteurs ont des droits selon leur(s) rôle(s). cette approche étant générique on peut l'appliquer donc sur n'importe quelles données.

M. mâïzi a schématisée cette approche dans un premier temps comme suit : 
******************************** ICI L'ANCIEN UML **************************************************

********************** ICI LES INCONVÉNIENTS *******************************************************

proposition de l'alternative suivante : 
**************************** ICI LE NOUVEAU UML *********************************************

L'héritage : pas tout a fait ça
Le principe de l'héritage dans postgresql n'est pas tout a fait au point ( cf. doc postgresql ). M. Maïzi a mis au point un moyen utilisant les triggers qui permet une utilisation plus sûre du mécanisme.
********************* Mettre l'UML du diagramme de l'implémentation **********************************

Première brique :
pour chaque table visité on veut présenter au visiteur les différents tuples de la table ainsi que les opérations que le visiteur peut effectuer sur chacun des tuples

5. adbapi le retour :
    une fois la première proposition des roles mise en place, nous avons continuer le développement 
d'adbapi :
    * implémentation de l'algébre :
    
    * implémentation des schémas :
    les schémas dans une base de données forment un moyen d'encapsulation de plusieurs tables dans une même entité logique. Face a une prochaine intégration des schémas dans la construction des futurs bases de données, nous sommes contraint de faire en sorte q'adbapi pressne en charge ces schémas.

    On considère les schémas comme étant des objets qui font partie d'une base de données. chaque schémas contient des tables.
*********************** ICI METRE LE DIAGRAMME UML AVEC LES SCHEMAS **************************************

    * implémentation du mécanisme de jointure :
    adbapi ne permettait pas de faire une séléction impliquant plusieurs tables. ce problème oblige à créer une vue au niveau de la base de données. Cette vue sert à mettre en relation les tables souhaitées. Après, et seulement après cette manoeuvre, qu'on peut récupérer le résultat voulu en effectuant la séléction sur la vue générée.
Le but fixé été de pouvoir éxécuter des instructions de ce type :
<code>
    acteur.id.setVal( 2 )
    resultat = acces_voiture.getRel( acteur )
</code>
en ayant ce diagramme UML :

****************************************** ICI UML ***************************************************

explication : 
acteur.id.setVal( 2 ) : initialisation de l'identifiant d'un acteur à 2
resultat = acces_voiture.getRel( acteur ) : en passant l'objet acteur à la méthode getRel() on veut récupérer la liste des roles ainsi que des voitures qui entrent en relation avec l'acteur dont l'identifiant est 2.
voici un schéma illustrant la situation précédente :

****************************************  ICI METTRE lE SCHEMA ILLUSTRANT ***************************************

Solution choisie : 
toute solution devait se baser sur les clés étrangères déjà implémentées dans les SGBDR. en effet les 
clés étrangères est le mécanisme qui permet de lier les tables entres elles. 
Donc la première étape été d'identifier les attributs des tables constituant des clés étrangères puis de stocker dans chacun de ces attributs le nom de la table et 
de l'attribut pointé. 
La deuxième étape consiste à stocker chaque objet adbapiTable le nom des différentes tables pointées ainsi 
que les noms des attributs constituants la clé étrangère. Cette étape est optionnelle mais son résultat permet de 
faciliter certains traitements ultérieurs. 
Puisque chaque clé étrangère correspond à une clé primaire dans une autre relation, la troisième étape consiste à stocker le noms des champs de la clé primaire dans chaque objet adbapiTable.
On peut voir le résultat à cette page #page

    * Problème : le type de données manipulées
Pour rappel, un des principaux buts pour lesquels adbapi a été réalisée, est de permettre au programmeur une 
manipulation aisées des différentes informations extraites d'une base de données. Cette manipulation se matérialise pas l'utilisation des types python de base. 
De plus, le programmeur n'a pas besoin de savoir le type de données dans une base de données, car ce dernier peut avoir 
différents type selon le SGBDR utilisé.
Afin d'arriver à cette finalité, l'api doit vérifier que le type des paramétres fournis par le programmeur est bien 
cohérent avec le vrai type de l'objet manipulé.

On intérrogeant les métas données du SGBDR utilisé, on peut savoir le type correspondant à un champ 
d'une table. En stockant cette information, nous sommes capables de controler et de convertir si nécessaire les données 
circulant dans les deux sens suivants : adbapi <--> programmeur.
Le hic est : d'une part chaque SGBDR a ses propres types et d'autre part chaque driver utilisé pour assurer la 
communication avec le SGBDR effectue une convertion vers un type python. Par conséquent on a besoin d'un outil de 
qui vérifie les deux points suivant :
	- lors d'un monChamp.setVAl( valeur ) nous devons vérifier que le type de «valeur» correspond au type du champ 	
«monChamp»
	- lors d'un getVal() nous devons garantir que la valeur retournée est bien de type python est qu'elle est 
cohérente.
Deux solution s'imposent :
	- définir une classe correspondant à chaque type connu pour chaque SGBDR puis dans la classe AdbapiField 
ajouter un attribut qui est une instance de la classe correspondant au type du champ. cette solution présente un 
inconvéniant majeur qui est la multitude d'objet en mémoire
	- la deuxième solution qui est plus raisonnable consiste à créer une classe AdbapiTypes qui sera associée au 
SGBDR utilisé et qui contiendra les méthodes nécessaire pour la conversion dans le sens voulu. C'est cette solution qui 
a été retenue vu la différence du nombre d'objets crées et le coût que ça engendrerait.

AdbapiOracle :
	Le service informatique utilise aussi un SGBDR de type Oracle. Cette utilisation et le besoin urgent de pouvoir 
développer des applications utilisants des informations stockées dans ce type d'SGBDR nous à inciter à mettre en place 
un module AdbapiOracle qui au même titre que AdbapiPg va se charger de construire l'arbre d'objet adbapi.
	L'organisation d'une base de données Oracle est différente de celle de PostgreSQL. On retrouve les schémas 
"TABLESPACES" comme étant des entités physiques et non logique de stockage, les éspaces de nommage sont le nom du 
propriétaire "OWNER" ou l'identifiant de l'utilisateur qui se connecte "USER". les vues quant à elles forment des 
objets à part entière car elles ne sont attachées à aucun "TABLESPACE" mais plutôt au propriétaire "OWNER".

