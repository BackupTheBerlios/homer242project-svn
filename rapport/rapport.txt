le cadre du stage
Le stage en entreprise est un des modules obligatoires pour la validation de la 3ème année de l'I.U.P. Génie Mathématiques et Informatique. il s'inscrit, parmi d'autre, dans la politique générale des l'I.U.P. qui est de fournir des maitres-ingénieurs qualifiés, autonomes et ayant une bonne connaissance des besoins des entreprises.

pourquoi ? (le but du stage)
Pour les étudiants de l'I.U.P. le stage s'avère une bonne batterie de test de certaines notions acquises que se soit à l'I.U.P. ou lors d'autre cursus. Le stage permet aussi de se familiariser avec le monde du travail. Il ne faut pas oublier qu'il est source d'apprentissage puisque il crée un climat de communication entre plusieurs personnes (encadrants stagiaires et autres individus).

où ?
Au sein du service informatique de l'UFR des sciences de l'Université de Montpellier II.

quand ?
Du début du mois de Septembre jusqu'à la fin du mois de décembre.

le sujet du stage
le stage a pour sujet : la réalisation et la mise au point de briques élémentaires génériques nécessaires à la mise en place d'application web. Il s'inscrit dans le cadre du développement d'une plate-forme Web présentant l'offre d'enseignement de l'UFR des sciences.

chronologie des événements
- prise en main et réécriture d'adbapi  -----> petite participation dans le projet PIE ------> soumission des modifications ------> prise en compte des suggestion dans adbapi v0.2 -----> restructuration d'adbapi en un "vrai" programme objet ------> validation ------> sortie d'adbapi v0.3 ( 1 mois )
- réflexion sur les briques de bases -------> mise en place du mécanisme de rôle -----> retour à adbapi ........

matériel et méthodes
    matériel
    le matériel utilisé pour le développement est un PC DELL GX150 :
        - processeur : intel celeron 800Mhz
        - mémoire : 324 Mo
        - connexion réseau intranet 
        - connexion internet

    logiciels
        - système d'exploitation : Linux Fedora Core 4
        - langage de programmation : Python 2.4
        - subversion
        - trac 0.8
        - SGBDR : Postgresql 7.4
        - serveur http : Apache 2
        - moteur de template ClearSilver

    méthodes
     	- eXtrem Programming
        - travail collaboratif ( subversion et trac )
        - programmation par objet ( python )
        - Web et cgi


- subversion

Subversion est un logiciel informatique de contrôle de version.
Il permet de travailler collaborativement en proposant un dépot centralisé pour les fichiers d'un projet.
Il est utilisé sur internet pour les projets opensource.

- trac

Trac est un logiciel écrit en python qui integre plusieurs outils pour le développement de projet collaboratif. Il est composé d'un wiki, d'un système de tickets et d'une interface pour subversion.
Un wiki est un site web dynamique qui permet d'organiser rapidement des informations. Chaque développeur qui possède un compte sur trac peut editer des pages directement dans la naviguateur.

- Extreme programming

 L'Extreme Programming (XP) est une méthode agile de gestion de projet informatique, dont l'objectif est de permettre de gérer des projets de manière simple et efficace. Cette méthode a été inventée par Kent Beck et Ward Cunningham.

http://fr.wikipedia.org/wiki/Extreme_programming

- Python

Python est un langage de programmation interprété, multi-paradigme, ce qui signifie qu'il autorise la programmation impérative structurée, orientée objet, et fonctionnelle. Il est doté d'un typage dynamique (ce qui ne l'empêche pas de disposer d'un typage fort), d'une gestion automatique de la mémoire par ramasse-miettes et d'un système de gestion d'exceptions.
Il permet entre autre de développer des applications web grace à des modules (cgi).

- ClearSilver

ClearSilver est un système de patron (en anglais: template). Il permet de séparer le fond (le contenu informationnel) de la forme (la manière dont il est présenté).
Dans un 1er temps, on crée la template puis on remplis les cases par des informations extraites d'une base de donnée.
-- SCHEMA §§§§§§- ----
ClearSilver est particulièrement intéressant car il fournit un module pour python.

3.adbapi
adbapi est une application écrite en Python et offre une interface permettant d'exécuter des requêtes SQL simples. 
Elle essaye de simplifier la tache des programmeurs en leur évitant l'écriture de code SQL tout en favorisant la clarté des applications écrites.
aDBapi offre à ses utilisateurs les méthodes SQL suivantes : INSERT, SELECT, UPDATE et DELETE ainsi que d'autres fonctionnalités détaillés plus bas.

    adbapi v0.1
comme toute première version, aDBapi décelait quelques inconvénients (et non pas des bugs) :
    - le non respect de certains principes de la programmation orienté objet (utilisation de variable globale, décapsulation des attributs des classe ....etc)
    - la méthode aDBapiTable.DELETE permettait de supprimer tous les tuples d'une table ce qui la rend dangereuse.
    - lors d'un commit, le développeur été incapable de savoir si une transaction s'est bien déroulées ou non.
    - la structure de l'application ne permettait pas l'utilisation de différents modules pour communiquer avec les différents SGBDR
        
    adbapi v0.2
elle essaye de résoudre les différents problèmes de la précédente version. Le plus important changement concerne la structure de l'application. la figure suivante schématise la nouvelle structure : 

************* ICI METTRE L'UML ******************************** avec des notes explicatives *****************************

    
    adbapi v0.3
le besoin de s'éloigner le plus possible du langage SQL tout en écrivant des requêtes correctes n'a pas été tout à fait atteint. 
En effet, prenant l'exemple de cette requête : [afficher le nom des personnes ayant plus de 15 ans et moins de 36 ans]; Le programmeur est incapable d'exécuter celle-ci puisque adbapi n'offre pas le moyen d'exprimer des inégalités entre les valeurs.
Pour combler ce vide, M. Maïzi a réécrit la classe adbapiField en lui ajoutant les fonctionnalités souhaitée.
Le principe est d'utiliser une algèbre qui permet de spécifier les contraintes sur les attributs. exemple :


4. Systeme d'information
le service informatique de l'UFR propose souvent de nouveaux services au core enseignant ainsi qu'aux étudiants; 
Ceci implique la création de nouvelles applications (Web entre autre). Une application Web est couplée, dans la plupart du temps, à une base de données. 
Afin de donner plus de liberté aux enseignants dans la manipulation des données qui les intéressent, Une approche a vu le jour : on peut considérer un system d'information comme étant un ensemble de donnée sur lesquelles des acteurs ont des droits selon leur(s) rôle(s). cette approche étant générique on peut l'appliquer donc sur n'importe quelles données.

M. mâïzi a schématisée cette approche dans un premier temps comme suit : 
******************************** ICI L'ANCIEN UML **************************************************

********************** ICI LES INCONVÉNIENTS *******************************************************

proposition de l'alternative suivante : 
**************************** ICI LE NOUVEAU UML *********************************************

L'héritage : pas tout a fait ça
Le principe de l'héritage dans postgresql n'est pas tout a fait au point ( cf. doc postgresql ). M. Maïzi a mis au point un moyen utilisant les triggers qui permet une utilisation plus sûre du mécanisme.
********************* Mettre l'UML du diagramme de l'implémentation **********************************

Première brique :
pour chaque table visité on veut présenter au visiteur les différents tuples de la table ainsi que les opérations que le visiteur peut effectuer sur chacun des tuples

5. adbapi le retour :
    une fois la première proposition des roles mise en place, nous avons continuer le développement 
d'adbapi :
    * implémentation de l'algébre :
    
    * implémentation des schémas :
    les schémas dans une base de données forment un moyen d'encapsulation de plusieurs tables dans une même entité logique. Face a une prochaine intégration des schémas dans la construction des futurs bases de données, nous sommes contraint de faire en sorte q'adbapi pressne en charge ces schémas.

    On considère les schémas comme étant des objets qui font partie d'une base de données. chaque schémas contient des tables.
*********************** ICI METRE LE DIAGRAMME UML AVEC LES SCHEMAS **************************************

    * implémentation du mécanisme de jointure :
    adbapi ne permettait pas de faire une séléction impliquant plusieurs tables. ce problème oblige à créer une vue au niveau de la base de données. Cette vue sert à mettre en relation les tables souhaitées. Après, et seulement après cette manoeuvre, qu'on peut récupérer le résultat voulu en effectuant la séléction sur la vue générée.
Le but fixé été de pouvoir éxécuter des instructions de ce type :
<code>
    acteur.id.setVal( 2 )
    resultat = acces_voiture.getRel( acteur )
</code>
en ayant ce diagramme UML :

****************************************** ICI UML ***************************************************

explication : 
acteur.id.setVal( 2 ) : initialisation de l'identifiant d'un acteur à 2
resultat = acces_voiture.getRel( acteur ) : en passant l'objet acteur à la méthode getRel() on veut récupérer la liste des roles ainsi que des voitures qui entrent en relation avec l'acteur dont l'identifiant est 2.
voici un schéma illustrant la situation précédente :

****************************************  ICI METTRE lE SCHEMA ILLUSTRANT ***************************************

Solution choisie : 
toute solution devait se baser sur les clés étrangères déjà implémentées dans les SGBDR. en effet les 
clés étrangères est le mécanisme qui permet de lier les tables entres elles. 
Donc la première étape été d'identifier les attributs des tables constituant des clés étrangères puis de stocker dans chacun de ces attributs le nom de la table et 
de l'attribut pointé. 
La deuxième étape consiste à stocker chaque objet adbapiTable le nom des différentes tables pointées ainsi 
que les noms des attributs constituants la clé étrangère. Cette étape est optionnelle mais son résultat permet de 
faciliter certains traitements ultérieurs. 
Puisque chaque clé étrangère correspond à une clé primaire dans une autre relation, la troisième étape consiste à stocker le noms des champs de la clé primaire dans chaque objet adbapiTable.
On peut voir le résultat à cette page #page

    * Problème : le type de données manipulées
Pour rappel, un des principaux buts pour lesquels adbapi a été réalisée, est de permettre au programmeur une 
manipulation aisées des différentes informations extraites d'une base de données. Cette manipulation se matérialise pas l'utilisation des types python de base. 
De plus, le programmeur n'a pas besoin de savoir le type de données dans une base de données, car ce dernier peut avoir 
différents type selon le SGBDR utilisé.
Afin d'arriver à cette finalité, l'api doit vérifier que le type des paramétres fournis par le programmeur est bien 
cohérent avec le vrai type de l'objet manipulé.

On intérrogeant les métas données du SGBDR utilisé, on peut savoir le type correspondant à un champ 
d'une table. En stockant cette information, nous sommes capables de controler et de convertir si nécessaire les données 
circulant dans les deux sens suivants : adbapi <--> programmeur.
Le hic est : d'une part chaque SGBDR a ses propres types et d'autre part chaque driver utilisé pour assurer la 
communication avec le SGBDR effectue une convertion vers un type python. Par conséquent on a besoin d'un outil de 
qui vérifie les deux points suivant :
	- lors d'un monChamp.setVAl( valeur ) nous devons vérifier que le type de «valeur» correspond au type du champ 	
«monChamp»
	- lors d'un getVal() nous devons garantir que la valeur retournée est bien de type python est qu'elle est 
cohérente.
Deux solution s'imposent :
	- définir une classe correspondant à chaque type connu pour chaque SGBDR puis dans la classe AdbapiField 
ajouter un attribut qui est une instance de la classe correspondant au type du champ. cette solution présente un 
inconvéniant majeur qui est la multitude d'objet en mémoire
	- la deuxième solution qui est plus raisonnable consiste à créer une classe AdbapiTypes qui sera associée au 
SGBDR utilisé et qui contiendra les méthodes nécessaire pour la conversion dans le sens voulu. C'est cette solution qui 
a été retenue vu la différence du nombre d'objets crées et le coût que ça engendrerait.

AdbapiOracle :
	Le service informatique utilise aussi un SGBDR de type Oracle. Cette utilisation et le besoin urgent de pouvoir 
développer des applications utilisants des informations stockées dans ce type d'SGBDR nous à inciter à mettre en place 
un module AdbapiOracle qui au même titre que AdbapiPg va se charger de construire l'arbre d'objet adbapi.
	L'organisation d'une base de données Oracle est différente de celle de PostgreSQL. On retrouve les schémas 
"TABLESPACES" comme étant des entités physiques et non logique de stockage, les éspaces de nommage sont le nom du 
propriétaire "OWNER" ou l'identifiant de l'utilisateur qui se connecte "USER". les vues quant à elles forment des 
objets à part entière car elles ne sont attachées à aucun "TABLESPACE" mais plutôt au propriétaire "OWNER".

6. Les Droits :
les droits qu'un acteur a sur une donnée sont stockées aux niveau de la base de donnée. Certes c'est une solution mais 
elle montre des défauts :
    * on ne peut pas donner des droits sur un ensemble d'attributs mais plutôt sur tout les attributs d'une donnée 
(tuple) .
    * de plus il est difficile de mettre en place un systeme qui permet de définir en cascade les droits sur plusieurs 
données, ex. : un résponsable de spécialité doit avoir le droit d'effectuer certaines opérations sur sa spécialité et 
de consulter les candidatures pour les approuver; Donc changer l'état d'une candidaure donc éditer une candidature.
Tous ceci parsequ'il a le rôle de résponsable de spécialité.
Le modèle actuel ne permet pas de répondre à ces problèmes ce qui nous obligent à jeter tous ce que nous avons fait 
jusqu'à présent (principe de l'eXtrem Programming oblige) et de faire une autre proposition.

6.1. Les patrons s'en chargent !
L'idée est la suivante : lors de la présentation d'une donnée à un acteur du système d'information, on utilisera un patron qui n'affiche que les champs 
susceptibles d'être consulter ou modifier et ceci selon les droits que l'acteur a par rapport à la donnée.

6.2. Rôles en cascade
Le but est d'associer à un rôles principale un ou plusieurs autres rôles dis annexes. Par conséquent un acteur 
ayant un rôle principale sur une donnée se voit attribuer des rôles annexes. Mais il ne faut pas oublier de spécifier 
que le rôle annexe (dans notre cas : le résponsable de condidatures) est posé sur tous les tuples d'une même 
table (la table contenant les candidatures à la spécialité). Donc un role annexe doit avoir un attribut qui spécifie 
la table sur laquelle s'applique ce role.

**********METTRE ICI LE SCHEMA UML**************

6.3 
